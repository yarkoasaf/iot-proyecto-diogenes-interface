<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monitor de Basurero</title>
  <!-- Bootstrap Cosmo Theme (Bootswatch) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/cosmo/bootstrap.min.css">
  <style>
    canvas { margin-top: 20px; }

    /* Solo cambia los colores de los botones */
    #btnConnect { background-color: #28a745; border-color: #28a745; color: #fff; }   /* Verde */
    #btnStart { background-color: #007bff; border-color: #007bff; color: #fff; }    /* Azul */
    #btnStop { background-color: #ffc107; border-color: #ffc107; color: #212529; }  /* Amarillo */
    #btnLimpiar { background-color: #dc3545; border-color: #dc3545; color: #fff; }  /* Rojo */
    [onclick="cargarDatosPrueba()"] { background-color: #007bff; border-color: #007bff; color: #fff; } /* Azul */
  </style>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-light">
  <div class="container py-4">
    <h2 class="mb-4 text-primary">Datos en tiempo real</h2>
    <div class="mb-3">
      <button id="btnConnect" class="btn btn-success me-2">Conectar</button>
      <button id="btnStart" class="btn btn-primary me-2">Iniciar</button>
      <button id="btnStop" class="btn btn-warning me-2">Detener y Guardar CSV</button>
      <button onclick="cargarDatosPrueba()" class="btn btn-info me-2">Cargar datos de prueba</button>
      <button id="btnLimpiar" class="btn btn-danger">Limpiar</button>
    </div>
    <div id="status" class="alert alert-secondary mb-4">Estado: esperando conexión...</div>

    <!-- KPIs -->
    <div class="row mb-4">
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Promedio Distancia</div>
          <div class="card-body"><p id="kpiDistancia" class="card-text fs-4">0 cm</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Promedio Peso</div>
          <div class="card-body"><p id="kpiPeso" class="card-text fs-4">0 %</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Nivel antes de alarma</div>
          <div class="card-body"><p id="kpiAlarma" class="card-text fs-4">0 %</p></div>
        </div>
      </div>
      <div class="col-md-3">
        <div class="card text-center">
          <div class="card-header">Tiempo medio detección</div>
          <div class="card-body"><p id="kpiTiempo" class="card-text fs-4">0 s</p></div>
        </div>
      </div>
    </div>

    <!-- Tabla -->
    <div class="table-responsive mb-4">
      <table id="dataTable" class="table table-bordered table-striped">
        <thead class="table-dark">
          <tr><th>Timestamp</th><th>Distancia (cm)</th><th>Peso (%)</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Gráfico -->
    <div class="bg-white p-3 rounded shadow-sm">
      <canvas id="grafico" width="600" height="300"></canvas>
    </div>
  </div>

  <script>
    let port, reader, keepReading = false;
    let lines = [];
    let distanciaAnterior = null, pesoAnterior = null;

    // KPIs acumuladores
    let sumaDistancia = 0, sumaPeso = 0, count = 0;
    let sumaTiempoDeteccion = 0, eventosDeteccion = 0;
    let ultimoCambio = null;
    let pesosAntesAlarma = [];

    // Chart.js setup
    const ctx = document.getElementById('grafico').getContext('2d');
    const grafico = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: 'Distancia (cm)', data: [], borderColor: 'blue', fill: false },
          { label: 'Peso (%)', data: [], borderColor: 'green', fill: false }
        ]
      },
      options: { responsive: true }
    });

    function setStatus(msg) {
      document.getElementById('status').textContent = "Estado: " + msg;
    }

    async function connect() {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        reader = port.readable.getReader();
        setStatus("conectado");
      } catch (e) {
        setStatus("error de conexión: " + e.message);
      }
    }

    async function start() {
      keepReading = true;
      const decoder = new TextDecoderStream();
      const readableStreamClosed = port.readable.pipeTo(decoder.writable);
      const inputStream = decoder.readable;
      const lineReader = inputStream.getReader();

      while (keepReading) {
        const { value, done } = await lineReader.read();
        if (done) break;
        if (value) {
          const match = value.match(/Distancia: (\d+) cm \| Peso: (\d+)/);
          if (match) {
            const distancia = parseInt(match[1]);
            const peso = parseInt(match[2]);

            const cambioDistancia = distancia !== distanciaAnterior;
            const cambioPeso = peso !== pesoAnterior;

            if (cambioDistancia || cambioPeso) {
              const ts = new Date().toISOString();
              lines.push(`${ts},${distancia},${peso}`);
              addRow(ts, distancia, peso);
              distanciaAnterior = distancia;
              pesoAnterior = peso;
            }
          }
        }
      }
    }

  function cargarDatosPrueba() {
  const datosPrueba = [
    { ts: "2025-11-18T09:00:00Z", distancia: 120, peso: 40 },
    { ts: "2025-11-18T09:01:00Z", distancia: 118, peso: 45 },
    { ts: "2025-11-18T09:02:00Z", distancia: 115, peso: 50 },
    { ts: "2025-11-18T09:03:00Z", distancia: 110, peso: 80 },
    { ts: "2025-11-18T09:04:00Z", distancia: 108, peso: 85 },
    { ts: "2025-11-18T09:05:00Z", distancia: 105, peso: 90 }
  ];

  datosPrueba.forEach(d => {
    lines.push(`${d.ts},${d.distancia},${d.peso}`);
    addRow(d.ts, d.distancia, d.peso);
  });

  setStatus("Datos de prueba cargados");
}


    function addRow(ts, distancia, peso) {
    // Tabla
    const table = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
    const row = table.insertRow();
    row.insertCell(0).textContent = ts;
    row.insertCell(1).textContent = distancia;
    row.insertCell(2).textContent = peso;

    // Gráfico
    grafico.data.labels.push(ts);
    grafico.data.datasets[0].data.push(distancia);
    grafico.data.datasets[1].data.push(peso);
    grafico.update();

    // KPIs
    sumaDistancia += distancia;
    sumaPeso += peso;
    count++;

    if (ultimoCambio) {
      const delta = (new Date(ts) - ultimoCambio) / 1000;
      sumaTiempoDeteccion += delta;
      eventosDeteccion++;
    }
    ultimoCambio = new Date(ts);

    if (peso > 80) pesosAntesAlarma.push(peso);

    actualizarKPIs();

    // --- Autoguardado cuando peso vuelve a 0 ---
    if (peso === 0 && pesoAnterior !== 0 && lines.length > 0) {
      autoGuardarYLimpiar();
    }
  }

  function autoGuardarYLimpiar() {
    // Guardar CSV automáticamente
    const header = "timestamp,distancia_cm,peso_pct\n";
    const csv = header + lines.join("\n");
    const blob = new Blob([csv], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `mediciones_${new Date().toISOString()}.csv`;
    a.click();
    URL.revokeObjectURL(url);

    // Limpiar datos
    lines = [];
    sumaDistancia = 0; sumaPeso = 0; count = 0;
    sumaTiempoDeteccion = 0; eventosDeteccion = 0;
    pesosAntesAlarma = [];
    ultimoCambio = null;

    // Limpiar tabla
    const tableBody = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = "";

    // Limpiar gráfico
    grafico.data.labels = [];
    grafico.data.datasets[0].data = [];
    grafico.data.datasets[1].data = [];
    grafico.update();

    // Reset KPIs
    actualizarKPIs();

    setStatus("Autoguardado realizado y datos reiniciados");
  }

    function limpiarDatos() {
      if (!confirm("¿Seguro que deseas limpiar todos los datos? Esta acción no se puede deshacer.")) {
        setStatus("Limpieza cancelada");
        return;
      }
      lines = [];
      sumaDistancia = 0; sumaPeso = 0; count = 0;
      sumaTiempoDeteccion = 0; eventosDeteccion = 0;
      pesosAntesAlarma = [];
      ultimoCambio = null;

      // Limpiar tabla
      const tableBody = document.getElementById('dataTable').getElementsByTagName('tbody')[0];
      tableBody.innerHTML = "";

      // Limpiar gráfico
      grafico.data.labels = [];
      grafico.data.datasets[0].data = [];
      grafico.data.datasets[1].data = [];
      grafico.update();

      // Reset KPIs
      actualizarKPIs();

      setStatus("Datos limpiados");
    }

    function actualizarKPIs() {
      document.getElementById('kpiDistancia').textContent = (sumaDistancia / count).toFixed(1) + " cm";
      document.getElementById('kpiPeso').textContent = (sumaPeso / count).toFixed(1) + " %";
      document.getElementById('kpiTiempo').textContent = eventosDeteccion > 0 ? (sumaTiempoDeteccion / eventosDeteccion).toFixed(1) + " s" : "0 s";
      document.getElementById('kpiAlarma').textContent = pesosAntesAlarma.length > 0 ? (pesosAntesAlarma.reduce((a,b)=>a+b,0)/pesosAntesAlarma.length).toFixed(1) + " %" : "0 %";
    }

    
    async function stopAndSave() {
      keepReading = false;
      try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch {}
      try { if (port) { await port.close(); } } catch {}
      setStatus("desconectado");

      const header = "timestamp,distancia_cm,peso_pct\n";
      const csv = header + lines.join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `mediciones_${new Date().toISOString()}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    document.getElementById('btnConnect').onclick = connect;
    document.getElementById('btnStart').onclick = start;
    document.getElementById('btnStop').onclick = stopAndSave;
    document.getElementById('btnLimpiar').onclick = limpiarDatos;

    if (!("serial" in navigator)) {
      setStatus("tu navegador no soporta Web Serial (usa Chrome/Edge de escritorio).");
    }
  </script>
</body>
</html>
